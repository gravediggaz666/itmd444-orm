{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchemaGenerator = void 0;\nconst subscription_1 = require(\"@graphql-yoga/subscription\");\nconst graphql_1 = require(\"graphql\");\nconst errors_1 = require(\"../errors\");\nconst types_1 = require(\"../helpers/types\");\nconst getMetadataStorage_1 = require(\"../metadata/getMetadataStorage\");\nconst create_1 = require(\"../resolvers/create\");\nconst graphql_version_1 = require(\"../utils/graphql-version\");\nconst build_context_1 = require(\"./build-context\");\nconst definition_node_1 = require(\"./definition-node\");\nconst utils_1 = require(\"./utils\");\nclass SchemaGenerator {\n  static generateFromMetadata(options) {\n    this.checkForErrors(options);\n    build_context_1.BuildContext.create(options);\n    (0, getMetadataStorage_1.getMetadataStorage)().build(options);\n    this.buildTypesInfo(options.resolvers);\n    const orphanedTypes = options.orphanedTypes ?? [];\n    const prebuiltSchema = new graphql_1.GraphQLSchema({\n      query: this.buildRootQueryType(options.resolvers),\n      mutation: this.buildRootMutationType(options.resolvers),\n      subscription: this.buildRootSubscriptionType(options.resolvers),\n      directives: options.directives\n    });\n    const finalSchema = new graphql_1.GraphQLSchema({\n      ...prebuiltSchema.toConfig(),\n      types: this.buildOtherTypes(orphanedTypes)\n    });\n    build_context_1.BuildContext.reset();\n    this.usedInterfaceTypes = new Set();\n    if (!options.skipCheck) {\n      const {\n        errors\n      } = (0, graphql_1.graphqlSync)({\n        schema: finalSchema,\n        source: (0, graphql_1.getIntrospectionQuery)()\n      });\n      if (errors) {\n        throw new errors_1.GeneratingSchemaError(errors);\n      }\n    }\n    return finalSchema;\n  }\n  static checkForErrors(options) {\n    (0, graphql_version_1.ensureInstalledCorrectGraphQLPackage)();\n    if ((0, getMetadataStorage_1.getMetadataStorage)().authorizedFields.length !== 0 && options.authChecker === undefined) {\n      throw new Error(\"You need to provide `authChecker` function for `@Authorized` decorator usage!\");\n    }\n  }\n  static getDefaultValue(typeInstance, typeOptions, fieldName, typeName) {\n    const {\n      disableInferringDefaultValues\n    } = build_context_1.BuildContext;\n    if (disableInferringDefaultValues) {\n      return typeOptions.defaultValue;\n    }\n    const defaultValueFromInitializer = typeInstance[fieldName];\n    if (typeOptions.defaultValue !== undefined && defaultValueFromInitializer !== undefined && typeOptions.defaultValue !== defaultValueFromInitializer) {\n      throw new errors_1.ConflictingDefaultValuesError(typeName, fieldName, typeOptions.defaultValue, defaultValueFromInitializer);\n    }\n    return typeOptions.defaultValue !== undefined ? typeOptions.defaultValue : defaultValueFromInitializer;\n  }\n  static buildTypesInfo(resolvers) {\n    this.unionTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().unions.map(unionMetadata => {\n      const unionObjectTypesInfo = [];\n      const typesThunk = () => {\n        unionObjectTypesInfo.push(...unionMetadata.getClassTypes().map(objectTypeCls => this.objectTypesInfo.find(type => type.target === objectTypeCls)));\n        return unionObjectTypesInfo.map(it => it.type);\n      };\n      return {\n        unionSymbol: unionMetadata.symbol,\n        type: new graphql_1.GraphQLUnionType({\n          name: unionMetadata.name,\n          description: unionMetadata.description,\n          types: typesThunk,\n          resolveType: unionMetadata.resolveType ? this.getResolveTypeFunction(unionMetadata.resolveType, unionObjectTypesInfo) : instance => {\n            const instanceTarget = unionMetadata.getClassTypes().find(ObjectClassType => instance instanceof ObjectClassType);\n            if (!instanceTarget) {\n              throw new errors_1.UnionResolveTypeError(unionMetadata);\n            }\n            const objectTypeInfo = unionObjectTypesInfo.find(type => type.target === instanceTarget);\n            return objectTypeInfo?.type.name;\n          }\n        })\n      };\n    });\n    this.enumTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().enums.map(enumMetadata => {\n      const enumMap = (0, types_1.getEnumValuesMap)(enumMetadata.enumObj);\n      return {\n        enumObj: enumMetadata.enumObj,\n        type: new graphql_1.GraphQLEnumType({\n          name: enumMetadata.name,\n          description: enumMetadata.description,\n          values: Object.keys(enumMap).reduce((enumConfig, enumKey) => {\n            const valueConfig = enumMetadata.valuesConfig[enumKey] || {};\n            enumConfig[enumKey] = {\n              value: enumMap[enumKey],\n              description: valueConfig.description,\n              deprecationReason: valueConfig.deprecationReason\n            };\n            return enumConfig;\n          }, {})\n        })\n      };\n    });\n    this.objectTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().objectTypes.map(objectType => {\n      const objectSuperClass = Object.getPrototypeOf(objectType.target);\n      const hasExtended = objectSuperClass.prototype !== undefined;\n      const getSuperClassType = () => {\n        const superClassTypeInfo = this.objectTypesInfo.find(type => type.target === objectSuperClass) ?? this.interfaceTypesInfo.find(type => type.target === objectSuperClass);\n        return superClassTypeInfo ? superClassTypeInfo.type : undefined;\n      };\n      const interfaceClasses = objectType.interfaceClasses || [];\n      return {\n        metadata: objectType,\n        target: objectType.target,\n        type: new graphql_1.GraphQLObjectType({\n          name: objectType.name,\n          description: objectType.description,\n          astNode: (0, definition_node_1.getObjectTypeDefinitionNode)(objectType.name, objectType.directives),\n          extensions: objectType.extensions,\n          interfaces: () => {\n            let interfaces = interfaceClasses.map(interfaceClass => {\n              const interfaceTypeInfo = this.interfaceTypesInfo.find(info => info.target === interfaceClass);\n              if (!interfaceTypeInfo) {\n                throw new Error(`Cannot find interface type metadata for class '${interfaceClass.name}' ` + `provided in 'implements' option for '${objectType.target.name}' object type class. ` + `Please make sure that class is annotated with an '@InterfaceType()' decorator.`);\n              }\n              return interfaceTypeInfo.type;\n            });\n            if (hasExtended) {\n              const superClass = getSuperClassType();\n              if (superClass) {\n                const superInterfaces = superClass.getInterfaces();\n                interfaces = Array.from(new Set(interfaces.concat(superInterfaces)));\n              }\n            }\n            return interfaces;\n          },\n          fields: () => {\n            const fieldsMetadata = [];\n            if (objectType.interfaceClasses) {\n              const implementedInterfaces = (0, getMetadataStorage_1.getMetadataStorage)().interfaceTypes.filter(it => objectType.interfaceClasses.includes(it.target));\n              implementedInterfaces.forEach(it => {\n                fieldsMetadata.push(...(it.fields || []));\n              });\n            }\n            fieldsMetadata.push(...objectType.fields);\n            let fields = fieldsMetadata.reduce((fieldsMap, field) => {\n              const {\n                fieldResolvers\n              } = (0, getMetadataStorage_1.getMetadataStorage)();\n              const filteredFieldResolversMetadata = fieldResolvers.filter(it => it.kind === \"internal\" || resolvers.includes(it.target));\n              const fieldResolverMetadata = filteredFieldResolversMetadata.find(it => it.getObjectType() === field.target && it.methodName === field.name);\n              const type = this.getGraphQLOutputType(field.target, field.name, field.getType(), field.typeOptions);\n              const isSimpleResolver = field.simple !== undefined ? field.simple === true : objectType.simpleResolvers !== undefined ? objectType.simpleResolvers === true : false;\n              fieldsMap[field.schemaName] = {\n                type,\n                args: this.generateHandlerArgs(field.target, field.name, field.params),\n                resolve: fieldResolverMetadata ? (0, create_1.createAdvancedFieldResolver)(fieldResolverMetadata) : isSimpleResolver ? undefined : (0, create_1.createBasicFieldResolver)(field),\n                description: field.description,\n                deprecationReason: field.deprecationReason,\n                astNode: (0, definition_node_1.getFieldDefinitionNode)(field.name, type, field.directives),\n                extensions: {\n                  complexity: field.complexity,\n                  ...field.extensions,\n                  ...fieldResolverMetadata?.extensions\n                }\n              };\n              return fieldsMap;\n            }, {});\n            if (hasExtended) {\n              const superClass = getSuperClassType();\n              if (superClass) {\n                const superClassFields = (0, utils_1.getFieldMetadataFromObjectType)(superClass);\n                fields = {\n                  ...superClassFields,\n                  ...fields\n                };\n              }\n            }\n            return fields;\n          }\n        })\n      };\n    });\n    this.interfaceTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().interfaceTypes.map(interfaceType => {\n      const interfaceSuperClass = Object.getPrototypeOf(interfaceType.target);\n      const hasExtended = interfaceSuperClass.prototype !== undefined;\n      const getSuperClassType = () => {\n        const superClassTypeInfo = this.interfaceTypesInfo.find(type => type.target === interfaceSuperClass);\n        return superClassTypeInfo ? superClassTypeInfo.type : undefined;\n      };\n      const implementingObjectTypesTargets = (0, getMetadataStorage_1.getMetadataStorage)().objectTypes.filter(objectType => objectType.interfaceClasses && objectType.interfaceClasses.includes(interfaceType.target)).map(objectType => objectType.target);\n      const implementingObjectTypesInfo = this.objectTypesInfo.filter(objectTypesInfo => implementingObjectTypesTargets.includes(objectTypesInfo.target));\n      return {\n        metadata: interfaceType,\n        target: interfaceType.target,\n        type: new graphql_1.GraphQLInterfaceType({\n          name: interfaceType.name,\n          description: interfaceType.description,\n          astNode: (0, definition_node_1.getInterfaceTypeDefinitionNode)(interfaceType.name, interfaceType.directives),\n          interfaces: () => {\n            let interfaces = (interfaceType.interfaceClasses || []).map(interfaceClass => this.interfaceTypesInfo.find(info => info.target === interfaceClass).type);\n            if (hasExtended) {\n              const superClass = getSuperClassType();\n              if (superClass) {\n                const superInterfaces = superClass.getInterfaces();\n                interfaces = Array.from(new Set(interfaces.concat(superInterfaces)));\n              }\n            }\n            return interfaces;\n          },\n          fields: () => {\n            const fieldsMetadata = [];\n            if (interfaceType.interfaceClasses) {\n              const implementedInterfacesMetadata = (0, getMetadataStorage_1.getMetadataStorage)().interfaceTypes.filter(it => interfaceType.interfaceClasses.includes(it.target));\n              implementedInterfacesMetadata.forEach(it => {\n                fieldsMetadata.push(...(it.fields || []));\n              });\n            }\n            fieldsMetadata.push(...interfaceType.fields);\n            let fields = fieldsMetadata.reduce((fieldsMap, field) => {\n              const fieldResolverMetadata = (0, getMetadataStorage_1.getMetadataStorage)().fieldResolvers.find(resolver => resolver.getObjectType() === field.target && resolver.methodName === field.name);\n              const type = this.getGraphQLOutputType(field.target, field.name, field.getType(), field.typeOptions);\n              fieldsMap[field.schemaName] = {\n                type,\n                args: this.generateHandlerArgs(field.target, field.name, field.params),\n                resolve: fieldResolverMetadata ? (0, create_1.createAdvancedFieldResolver)(fieldResolverMetadata) : (0, create_1.createBasicFieldResolver)(field),\n                description: field.description,\n                deprecationReason: field.deprecationReason,\n                astNode: (0, definition_node_1.getFieldDefinitionNode)(field.name, type, field.directives),\n                extensions: {\n                  complexity: field.complexity,\n                  ...field.extensions\n                }\n              };\n              return fieldsMap;\n            }, {});\n            if (hasExtended) {\n              const superClass = getSuperClassType();\n              if (superClass) {\n                const superClassFields = (0, utils_1.getFieldMetadataFromObjectType)(superClass);\n                fields = {\n                  ...superClassFields,\n                  ...fields\n                };\n              }\n            }\n            return fields;\n          },\n          resolveType: interfaceType.resolveType ? this.getResolveTypeFunction(interfaceType.resolveType, implementingObjectTypesInfo) : instance => {\n            const typeTarget = implementingObjectTypesTargets.find(typeCls => instance instanceof typeCls);\n            if (!typeTarget) {\n              throw new errors_1.InterfaceResolveTypeError(interfaceType);\n            }\n            const objectTypeInfo = implementingObjectTypesInfo.find(type => type.target === typeTarget);\n            return objectTypeInfo?.type.name;\n          }\n        })\n      };\n    });\n    this.inputTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().inputTypes.map(inputType => {\n      const objectSuperClass = Object.getPrototypeOf(inputType.target);\n      const getSuperClassType = () => {\n        const superClassTypeInfo = this.inputTypesInfo.find(type => type.target === objectSuperClass);\n        return superClassTypeInfo ? superClassTypeInfo.type : undefined;\n      };\n      const inputInstance = new inputType.target();\n      return {\n        target: inputType.target,\n        type: new graphql_1.GraphQLInputObjectType({\n          name: inputType.name,\n          description: inputType.description,\n          extensions: inputType.extensions,\n          fields: () => {\n            let fields = inputType.fields.reduce((fieldsMap, field) => {\n              const defaultValue = this.getDefaultValue(inputInstance, field.typeOptions, field.name, inputType.name);\n              const type = this.getGraphQLInputType(field.target, field.name, field.getType(), {\n                ...field.typeOptions,\n                defaultValue\n              });\n              fieldsMap[field.name] = {\n                description: field.description,\n                type,\n                defaultValue,\n                astNode: (0, definition_node_1.getInputValueDefinitionNode)(field.name, type, field.directives),\n                extensions: field.extensions,\n                deprecationReason: field.deprecationReason\n              };\n              return fieldsMap;\n            }, {});\n            if (objectSuperClass.prototype !== undefined) {\n              const superClass = getSuperClassType();\n              if (superClass) {\n                const superClassFields = (0, utils_1.getFieldMetadataFromInputType)(superClass);\n                fields = {\n                  ...superClassFields,\n                  ...fields\n                };\n              }\n            }\n            return fields;\n          },\n          astNode: (0, definition_node_1.getInputObjectTypeDefinitionNode)(inputType.name, inputType.directives)\n        })\n      };\n    });\n  }\n  static buildRootQueryType(resolvers) {\n    const queriesHandlers = this.filterHandlersByResolvers((0, getMetadataStorage_1.getMetadataStorage)().queries, resolvers);\n    return new graphql_1.GraphQLObjectType({\n      name: \"Query\",\n      fields: this.generateHandlerFields(queriesHandlers)\n    });\n  }\n  static buildRootMutationType(resolvers) {\n    const mutationsHandlers = this.filterHandlersByResolvers((0, getMetadataStorage_1.getMetadataStorage)().mutations, resolvers);\n    if (mutationsHandlers.length === 0) {\n      return undefined;\n    }\n    return new graphql_1.GraphQLObjectType({\n      name: \"Mutation\",\n      fields: this.generateHandlerFields(mutationsHandlers)\n    });\n  }\n  static buildRootSubscriptionType(resolvers) {\n    const subscriptionsHandlers = this.filterHandlersByResolvers((0, getMetadataStorage_1.getMetadataStorage)().subscriptions, resolvers);\n    if (subscriptionsHandlers.length === 0) {\n      return undefined;\n    }\n    return new graphql_1.GraphQLObjectType({\n      name: \"Subscription\",\n      fields: this.generateSubscriptionsFields(subscriptionsHandlers)\n    });\n  }\n  static buildOtherTypes(orphanedTypes) {\n    const autoRegisteredObjectTypesInfo = this.objectTypesInfo.filter(typeInfo => typeInfo.metadata.interfaceClasses?.some(interfaceClass => {\n      const implementedInterfaceInfo = this.interfaceTypesInfo.find(it => it.target === interfaceClass);\n      if (!implementedInterfaceInfo) {\n        return false;\n      }\n      if (implementedInterfaceInfo.metadata.autoRegisteringDisabled) {\n        return false;\n      }\n      if (!this.usedInterfaceTypes.has(interfaceClass)) {\n        return false;\n      }\n      return true;\n    }));\n    return [...this.filterTypesInfoByOrphanedTypesAndExtractType(this.objectTypesInfo, orphanedTypes), ...this.filterTypesInfoByOrphanedTypesAndExtractType(this.interfaceTypesInfo, orphanedTypes), ...this.filterTypesInfoByOrphanedTypesAndExtractType(this.inputTypesInfo, orphanedTypes), ...autoRegisteredObjectTypesInfo.map(typeInfo => typeInfo.type)];\n  }\n  static generateHandlerFields(handlers) {\n    return handlers.reduce((fields, handler) => {\n      const type = this.getGraphQLOutputType(handler.target, handler.methodName, handler.getReturnType(), handler.returnTypeOptions);\n      fields[handler.schemaName] = {\n        type,\n        args: this.generateHandlerArgs(handler.target, handler.methodName, handler.params),\n        resolve: (0, create_1.createHandlerResolver)(handler),\n        description: handler.description,\n        deprecationReason: handler.deprecationReason,\n        astNode: (0, definition_node_1.getFieldDefinitionNode)(handler.schemaName, type, handler.directives),\n        extensions: {\n          complexity: handler.complexity,\n          ...handler.extensions\n        }\n      };\n      return fields;\n    }, {});\n  }\n  static generateSubscriptionsFields(subscriptionsHandlers) {\n    if (!subscriptionsHandlers.length) {\n      return {};\n    }\n    const {\n      pubSub,\n      container\n    } = build_context_1.BuildContext;\n    if (!pubSub) {\n      throw new errors_1.MissingPubSubError();\n    }\n    const basicFields = this.generateHandlerFields(subscriptionsHandlers);\n    return subscriptionsHandlers.reduce((fields, handler) => {\n      let subscribeFn;\n      if (handler.subscribe) {\n        subscribeFn = (source, args, context, info) => {\n          const subscribeResolverData = {\n            source,\n            args,\n            context,\n            info\n          };\n          return handler.subscribe(subscribeResolverData);\n        };\n      } else {\n        subscribeFn = (source, args, context, info) => {\n          const subscribeResolverData = {\n            source,\n            args,\n            context,\n            info\n          };\n          let topics;\n          if (typeof handler.topics === \"function\") {\n            const getTopics = handler.topics;\n            topics = getTopics(subscribeResolverData);\n          } else {\n            topics = handler.topics;\n          }\n          const topicId = handler.topicId?.(subscribeResolverData);\n          let pubSubIterable;\n          if (!Array.isArray(topics)) {\n            pubSubIterable = pubSub.subscribe(topics, topicId);\n          } else {\n            if (topics.length === 0) {\n              throw new errors_1.MissingSubscriptionTopicsError(handler.target, handler.methodName);\n            }\n            pubSubIterable = subscription_1.Repeater.merge([...topics.map(topic => pubSub.subscribe(topic, topicId))]);\n          }\n          if (!handler.filter) {\n            return pubSubIterable;\n          }\n          return (0, subscription_1.pipe)(pubSubIterable, (0, subscription_1.filter)(payload => {\n            const handlerData = {\n              payload,\n              args,\n              context,\n              info\n            };\n            return handler.filter(handlerData);\n          }));\n        };\n      }\n      fields[handler.schemaName].subscribe = (0, create_1.wrapResolverWithAuthChecker)(subscribeFn, container, handler.roles);\n      return fields;\n    }, basicFields);\n  }\n  static generateHandlerArgs(target, propertyName, params) {\n    return params.reduce((args, param) => {\n      if (param.kind === \"arg\") {\n        const type = this.getGraphQLInputType(target, propertyName, param.getType(), param.typeOptions, param.index, param.name);\n        const argDirectives = (0, getMetadataStorage_1.getMetadataStorage)().argumentDirectives.filter(it => it.target === target && it.fieldName === propertyName && it.parameterIndex === param.index).map(it => it.directive);\n        args[param.name] = {\n          description: param.description,\n          type,\n          defaultValue: param.typeOptions.defaultValue,\n          deprecationReason: param.deprecationReason,\n          astNode: (0, definition_node_1.getInputValueDefinitionNode)(param.name, type, argDirectives)\n        };\n      } else if (param.kind === \"args\") {\n        const argumentType = (0, getMetadataStorage_1.getMetadataStorage)().argumentTypes.find(it => it.target === param.getType());\n        if (!argumentType) {\n          throw new Error(`The value used as a type of '@Args' for '${propertyName}' of '${target.name}' ` + `is not a class decorated with '@ArgsType' decorator!`);\n        }\n        const inheritanceChainClasses = [argumentType.target];\n        for (let superClass = argumentType.target; superClass.prototype !== undefined; superClass = Object.getPrototypeOf(superClass)) {\n          inheritanceChainClasses.push(superClass);\n        }\n        for (const argsTypeClass of inheritanceChainClasses.reverse()) {\n          const inheritedArgumentType = (0, getMetadataStorage_1.getMetadataStorage)().argumentTypes.find(it => it.target === argsTypeClass);\n          if (inheritedArgumentType) {\n            this.mapArgFields(inheritedArgumentType, args);\n          }\n        }\n      }\n      return args;\n    }, {});\n  }\n  static mapArgFields(argumentType, args = {}) {\n    const argumentInstance = new argumentType.target();\n    argumentType.fields.forEach(field => {\n      const defaultValue = this.getDefaultValue(argumentInstance, field.typeOptions, field.name, argumentType.name);\n      const type = this.getGraphQLInputType(field.target, field.name, field.getType(), {\n        ...field.typeOptions,\n        defaultValue\n      });\n      args[field.schemaName] = {\n        description: field.description,\n        type,\n        defaultValue,\n        astNode: (0, definition_node_1.getInputValueDefinitionNode)(field.name, type, field.directives),\n        extensions: field.extensions,\n        deprecationReason: field.deprecationReason\n      };\n    });\n  }\n  static getGraphQLOutputType(target, propertyName, type, typeOptions = {}) {\n    let gqlType;\n    gqlType = (0, types_1.convertTypeIfScalar)(type);\n    if (!gqlType) {\n      const objectType = this.objectTypesInfo.find(it => it.target === type);\n      if (objectType) {\n        gqlType = objectType.type;\n      }\n    }\n    if (!gqlType) {\n      const interfaceType = this.interfaceTypesInfo.find(it => it.target === type);\n      if (interfaceType) {\n        this.usedInterfaceTypes.add(interfaceType.target);\n        gqlType = interfaceType.type;\n      }\n    }\n    if (!gqlType) {\n      const enumType = this.enumTypesInfo.find(it => it.enumObj === type);\n      if (enumType) {\n        gqlType = enumType.type;\n      }\n    }\n    if (!gqlType) {\n      const unionType = this.unionTypesInfo.find(it => it.unionSymbol === type);\n      if (unionType) {\n        gqlType = unionType.type;\n      }\n    }\n    if (!gqlType) {\n      throw new errors_1.CannotDetermineGraphQLTypeError(\"output\", target.name, propertyName);\n    }\n    const {\n      nullableByDefault\n    } = build_context_1.BuildContext;\n    return (0, types_1.wrapWithTypeOptions)(target, propertyName, gqlType, typeOptions, nullableByDefault);\n  }\n  static getGraphQLInputType(target, propertyName, type, typeOptions = {}, parameterIndex, argName) {\n    let gqlType;\n    gqlType = (0, types_1.convertTypeIfScalar)(type);\n    if (!gqlType) {\n      const inputType = this.inputTypesInfo.find(it => it.target === type);\n      if (inputType) {\n        gqlType = inputType.type;\n      }\n    }\n    if (!gqlType) {\n      const enumType = this.enumTypesInfo.find(it => it.enumObj === type);\n      if (enumType) {\n        gqlType = enumType.type;\n      }\n    }\n    if (!gqlType) {\n      throw new errors_1.CannotDetermineGraphQLTypeError(\"input\", target.name, propertyName, parameterIndex, argName);\n    }\n    const {\n      nullableByDefault\n    } = build_context_1.BuildContext;\n    return (0, types_1.wrapWithTypeOptions)(target, propertyName, gqlType, typeOptions, nullableByDefault);\n  }\n  static getResolveTypeFunction(resolveType, possibleObjectTypesInfo) {\n    return async (...args) => {\n      const resolvedType = await resolveType(...args);\n      if (!resolvedType || typeof resolvedType === \"string\") {\n        return resolvedType ?? undefined;\n      }\n      return possibleObjectTypesInfo.find(objectType => objectType.target === resolvedType)?.type.name;\n    };\n  }\n  static filterHandlersByResolvers(handlers, resolvers) {\n    return handlers.filter(query => resolvers.includes(query.target));\n  }\n  static filterTypesInfoByOrphanedTypesAndExtractType(typesInfo, orphanedTypes) {\n    return typesInfo.filter(it => orphanedTypes.includes(it.target)).map(it => it.type);\n  }\n}\nexports.SchemaGenerator = SchemaGenerator;\nSchemaGenerator.objectTypesInfo = [];\nSchemaGenerator.inputTypesInfo = [];\nSchemaGenerator.interfaceTypesInfo = [];\nSchemaGenerator.enumTypesInfo = [];\nSchemaGenerator.unionTypesInfo = [];\nSchemaGenerator.usedInterfaceTypes = new Set();","map":{"version":3,"names":["Object","defineProperty","exports","value","SchemaGenerator","subscription_1","require","graphql_1","errors_1","types_1","getMetadataStorage_1","create_1","graphql_version_1","build_context_1","definition_node_1","utils_1","generateFromMetadata","options","checkForErrors","BuildContext","create","getMetadataStorage","build","buildTypesInfo","resolvers","orphanedTypes","prebuiltSchema","GraphQLSchema","query","buildRootQueryType","mutation","buildRootMutationType","subscription","buildRootSubscriptionType","directives","finalSchema","toConfig","types","buildOtherTypes","reset","usedInterfaceTypes","Set","skipCheck","errors","graphqlSync","schema","source","getIntrospectionQuery","GeneratingSchemaError","ensureInstalledCorrectGraphQLPackage","authorizedFields","length","authChecker","undefined","Error","getDefaultValue","typeInstance","typeOptions","fieldName","typeName","disableInferringDefaultValues","defaultValue","defaultValueFromInitializer","ConflictingDefaultValuesError","unionTypesInfo","unions","map","unionMetadata","unionObjectTypesInfo","typesThunk","push","getClassTypes","objectTypeCls","objectTypesInfo","find","type","target","it","unionSymbol","symbol","GraphQLUnionType","name","description","resolveType","getResolveTypeFunction","instance","instanceTarget","ObjectClassType","UnionResolveTypeError","objectTypeInfo","enumTypesInfo","enums","enumMetadata","enumMap","getEnumValuesMap","enumObj","GraphQLEnumType","values","keys","reduce","enumConfig","enumKey","valueConfig","valuesConfig","deprecationReason","objectTypes","objectType","objectSuperClass","getPrototypeOf","hasExtended","prototype","getSuperClassType","superClassTypeInfo","interfaceTypesInfo","interfaceClasses","metadata","GraphQLObjectType","astNode","getObjectTypeDefinitionNode","extensions","interfaces","interfaceClass","interfaceTypeInfo","info","superClass","superInterfaces","getInterfaces","Array","from","concat","fields","fieldsMetadata","implementedInterfaces","interfaceTypes","filter","includes","forEach","fieldsMap","field","fieldResolvers","filteredFieldResolversMetadata","kind","fieldResolverMetadata","getObjectType","methodName","getGraphQLOutputType","getType","isSimpleResolver","simple","simpleResolvers","schemaName","args","generateHandlerArgs","params","resolve","createAdvancedFieldResolver","createBasicFieldResolver","getFieldDefinitionNode","complexity","superClassFields","getFieldMetadataFromObjectType","interfaceType","interfaceSuperClass","implementingObjectTypesTargets","implementingObjectTypesInfo","GraphQLInterfaceType","getInterfaceTypeDefinitionNode","implementedInterfacesMetadata","resolver","typeTarget","typeCls","InterfaceResolveTypeError","inputTypesInfo","inputTypes","inputType","inputInstance","GraphQLInputObjectType","getGraphQLInputType","getInputValueDefinitionNode","getFieldMetadataFromInputType","getInputObjectTypeDefinitionNode","queriesHandlers","filterHandlersByResolvers","queries","generateHandlerFields","mutationsHandlers","mutations","subscriptionsHandlers","subscriptions","generateSubscriptionsFields","autoRegisteredObjectTypesInfo","typeInfo","some","implementedInterfaceInfo","autoRegisteringDisabled","has","filterTypesInfoByOrphanedTypesAndExtractType","handlers","handler","getReturnType","returnTypeOptions","createHandlerResolver","pubSub","container","MissingPubSubError","basicFields","subscribeFn","subscribe","context","subscribeResolverData","topics","getTopics","topicId","pubSubIterable","isArray","MissingSubscriptionTopicsError","Repeater","merge","topic","pipe","payload","handlerData","wrapResolverWithAuthChecker","roles","propertyName","param","index","argDirectives","argumentDirectives","parameterIndex","directive","argumentType","argumentTypes","inheritanceChainClasses","argsTypeClass","reverse","inheritedArgumentType","mapArgFields","argumentInstance","gqlType","convertTypeIfScalar","add","enumType","unionType","CannotDetermineGraphQLTypeError","nullableByDefault","wrapWithTypeOptions","argName","possibleObjectTypesInfo","resolvedType","typesInfo"],"sources":["/Users/snawz1/node_modules/type-graphql/build/cjs/schema/schema-generator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchemaGenerator = void 0;\nconst subscription_1 = require(\"@graphql-yoga/subscription\");\nconst graphql_1 = require(\"graphql\");\nconst errors_1 = require(\"../errors\");\nconst types_1 = require(\"../helpers/types\");\nconst getMetadataStorage_1 = require(\"../metadata/getMetadataStorage\");\nconst create_1 = require(\"../resolvers/create\");\nconst graphql_version_1 = require(\"../utils/graphql-version\");\nconst build_context_1 = require(\"./build-context\");\nconst definition_node_1 = require(\"./definition-node\");\nconst utils_1 = require(\"./utils\");\nclass SchemaGenerator {\n    static generateFromMetadata(options) {\n        this.checkForErrors(options);\n        build_context_1.BuildContext.create(options);\n        (0, getMetadataStorage_1.getMetadataStorage)().build(options);\n        this.buildTypesInfo(options.resolvers);\n        const orphanedTypes = options.orphanedTypes ?? [];\n        const prebuiltSchema = new graphql_1.GraphQLSchema({\n            query: this.buildRootQueryType(options.resolvers),\n            mutation: this.buildRootMutationType(options.resolvers),\n            subscription: this.buildRootSubscriptionType(options.resolvers),\n            directives: options.directives,\n        });\n        const finalSchema = new graphql_1.GraphQLSchema({\n            ...prebuiltSchema.toConfig(),\n            types: this.buildOtherTypes(orphanedTypes),\n        });\n        build_context_1.BuildContext.reset();\n        this.usedInterfaceTypes = new Set();\n        if (!options.skipCheck) {\n            const { errors } = (0, graphql_1.graphqlSync)({ schema: finalSchema, source: (0, graphql_1.getIntrospectionQuery)() });\n            if (errors) {\n                throw new errors_1.GeneratingSchemaError(errors);\n            }\n        }\n        return finalSchema;\n    }\n    static checkForErrors(options) {\n        (0, graphql_version_1.ensureInstalledCorrectGraphQLPackage)();\n        if ((0, getMetadataStorage_1.getMetadataStorage)().authorizedFields.length !== 0 && options.authChecker === undefined) {\n            throw new Error(\"You need to provide `authChecker` function for `@Authorized` decorator usage!\");\n        }\n    }\n    static getDefaultValue(typeInstance, typeOptions, fieldName, typeName) {\n        const { disableInferringDefaultValues } = build_context_1.BuildContext;\n        if (disableInferringDefaultValues) {\n            return typeOptions.defaultValue;\n        }\n        const defaultValueFromInitializer = typeInstance[fieldName];\n        if (typeOptions.defaultValue !== undefined &&\n            defaultValueFromInitializer !== undefined &&\n            typeOptions.defaultValue !== defaultValueFromInitializer) {\n            throw new errors_1.ConflictingDefaultValuesError(typeName, fieldName, typeOptions.defaultValue, defaultValueFromInitializer);\n        }\n        return typeOptions.defaultValue !== undefined\n            ? typeOptions.defaultValue\n            : defaultValueFromInitializer;\n    }\n    static buildTypesInfo(resolvers) {\n        this.unionTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().unions.map(unionMetadata => {\n            const unionObjectTypesInfo = [];\n            const typesThunk = () => {\n                unionObjectTypesInfo.push(...unionMetadata\n                    .getClassTypes()\n                    .map(objectTypeCls => this.objectTypesInfo.find(type => type.target === objectTypeCls)));\n                return unionObjectTypesInfo.map(it => it.type);\n            };\n            return {\n                unionSymbol: unionMetadata.symbol,\n                type: new graphql_1.GraphQLUnionType({\n                    name: unionMetadata.name,\n                    description: unionMetadata.description,\n                    types: typesThunk,\n                    resolveType: unionMetadata.resolveType\n                        ? this.getResolveTypeFunction(unionMetadata.resolveType, unionObjectTypesInfo)\n                        : instance => {\n                            const instanceTarget = unionMetadata\n                                .getClassTypes()\n                                .find(ObjectClassType => instance instanceof ObjectClassType);\n                            if (!instanceTarget) {\n                                throw new errors_1.UnionResolveTypeError(unionMetadata);\n                            }\n                            const objectTypeInfo = unionObjectTypesInfo.find(type => type.target === instanceTarget);\n                            return objectTypeInfo?.type.name;\n                        },\n                }),\n            };\n        });\n        this.enumTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().enums.map(enumMetadata => {\n            const enumMap = (0, types_1.getEnumValuesMap)(enumMetadata.enumObj);\n            return {\n                enumObj: enumMetadata.enumObj,\n                type: new graphql_1.GraphQLEnumType({\n                    name: enumMetadata.name,\n                    description: enumMetadata.description,\n                    values: Object.keys(enumMap).reduce((enumConfig, enumKey) => {\n                        const valueConfig = enumMetadata.valuesConfig[enumKey] || {};\n                        enumConfig[enumKey] = {\n                            value: enumMap[enumKey],\n                            description: valueConfig.description,\n                            deprecationReason: valueConfig.deprecationReason,\n                        };\n                        return enumConfig;\n                    }, {}),\n                }),\n            };\n        });\n        this.objectTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().objectTypes.map(objectType => {\n            const objectSuperClass = Object.getPrototypeOf(objectType.target);\n            const hasExtended = objectSuperClass.prototype !== undefined;\n            const getSuperClassType = () => {\n                const superClassTypeInfo = this.objectTypesInfo.find(type => type.target === objectSuperClass) ??\n                    this.interfaceTypesInfo.find(type => type.target === objectSuperClass);\n                return superClassTypeInfo ? superClassTypeInfo.type : undefined;\n            };\n            const interfaceClasses = objectType.interfaceClasses || [];\n            return {\n                metadata: objectType,\n                target: objectType.target,\n                type: new graphql_1.GraphQLObjectType({\n                    name: objectType.name,\n                    description: objectType.description,\n                    astNode: (0, definition_node_1.getObjectTypeDefinitionNode)(objectType.name, objectType.directives),\n                    extensions: objectType.extensions,\n                    interfaces: () => {\n                        let interfaces = interfaceClasses.map(interfaceClass => {\n                            const interfaceTypeInfo = this.interfaceTypesInfo.find(info => info.target === interfaceClass);\n                            if (!interfaceTypeInfo) {\n                                throw new Error(`Cannot find interface type metadata for class '${interfaceClass.name}' ` +\n                                    `provided in 'implements' option for '${objectType.target.name}' object type class. ` +\n                                    `Please make sure that class is annotated with an '@InterfaceType()' decorator.`);\n                            }\n                            return interfaceTypeInfo.type;\n                        });\n                        if (hasExtended) {\n                            const superClass = getSuperClassType();\n                            if (superClass) {\n                                const superInterfaces = superClass.getInterfaces();\n                                interfaces = Array.from(new Set(interfaces.concat(superInterfaces)));\n                            }\n                        }\n                        return interfaces;\n                    },\n                    fields: () => {\n                        const fieldsMetadata = [];\n                        if (objectType.interfaceClasses) {\n                            const implementedInterfaces = (0, getMetadataStorage_1.getMetadataStorage)().interfaceTypes.filter(it => objectType.interfaceClasses.includes(it.target));\n                            implementedInterfaces.forEach(it => {\n                                fieldsMetadata.push(...(it.fields || []));\n                            });\n                        }\n                        fieldsMetadata.push(...objectType.fields);\n                        let fields = fieldsMetadata.reduce((fieldsMap, field) => {\n                            const { fieldResolvers } = (0, getMetadataStorage_1.getMetadataStorage)();\n                            const filteredFieldResolversMetadata = fieldResolvers.filter(it => it.kind === \"internal\" || resolvers.includes(it.target));\n                            const fieldResolverMetadata = filteredFieldResolversMetadata.find(it => it.getObjectType() === field.target && it.methodName === field.name);\n                            const type = this.getGraphQLOutputType(field.target, field.name, field.getType(), field.typeOptions);\n                            const isSimpleResolver = field.simple !== undefined\n                                ? field.simple === true\n                                : objectType.simpleResolvers !== undefined\n                                    ? objectType.simpleResolvers === true\n                                    : false;\n                            fieldsMap[field.schemaName] = {\n                                type,\n                                args: this.generateHandlerArgs(field.target, field.name, field.params),\n                                resolve: fieldResolverMetadata\n                                    ? (0, create_1.createAdvancedFieldResolver)(fieldResolverMetadata)\n                                    : isSimpleResolver\n                                        ? undefined\n                                        : (0, create_1.createBasicFieldResolver)(field),\n                                description: field.description,\n                                deprecationReason: field.deprecationReason,\n                                astNode: (0, definition_node_1.getFieldDefinitionNode)(field.name, type, field.directives),\n                                extensions: {\n                                    complexity: field.complexity,\n                                    ...field.extensions,\n                                    ...fieldResolverMetadata?.extensions,\n                                },\n                            };\n                            return fieldsMap;\n                        }, {});\n                        if (hasExtended) {\n                            const superClass = getSuperClassType();\n                            if (superClass) {\n                                const superClassFields = (0, utils_1.getFieldMetadataFromObjectType)(superClass);\n                                fields = { ...superClassFields, ...fields };\n                            }\n                        }\n                        return fields;\n                    },\n                }),\n            };\n        });\n        this.interfaceTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().interfaceTypes.map(interfaceType => {\n            const interfaceSuperClass = Object.getPrototypeOf(interfaceType.target);\n            const hasExtended = interfaceSuperClass.prototype !== undefined;\n            const getSuperClassType = () => {\n                const superClassTypeInfo = this.interfaceTypesInfo.find(type => type.target === interfaceSuperClass);\n                return superClassTypeInfo ? superClassTypeInfo.type : undefined;\n            };\n            const implementingObjectTypesTargets = (0, getMetadataStorage_1.getMetadataStorage)()\n                .objectTypes.filter(objectType => objectType.interfaceClasses &&\n                objectType.interfaceClasses.includes(interfaceType.target))\n                .map(objectType => objectType.target);\n            const implementingObjectTypesInfo = this.objectTypesInfo.filter(objectTypesInfo => implementingObjectTypesTargets.includes(objectTypesInfo.target));\n            return {\n                metadata: interfaceType,\n                target: interfaceType.target,\n                type: new graphql_1.GraphQLInterfaceType({\n                    name: interfaceType.name,\n                    description: interfaceType.description,\n                    astNode: (0, definition_node_1.getInterfaceTypeDefinitionNode)(interfaceType.name, interfaceType.directives),\n                    interfaces: () => {\n                        let interfaces = (interfaceType.interfaceClasses || []).map(interfaceClass => this.interfaceTypesInfo.find(info => info.target === interfaceClass).type);\n                        if (hasExtended) {\n                            const superClass = getSuperClassType();\n                            if (superClass) {\n                                const superInterfaces = superClass.getInterfaces();\n                                interfaces = Array.from(new Set(interfaces.concat(superInterfaces)));\n                            }\n                        }\n                        return interfaces;\n                    },\n                    fields: () => {\n                        const fieldsMetadata = [];\n                        if (interfaceType.interfaceClasses) {\n                            const implementedInterfacesMetadata = (0, getMetadataStorage_1.getMetadataStorage)().interfaceTypes.filter(it => interfaceType.interfaceClasses.includes(it.target));\n                            implementedInterfacesMetadata.forEach(it => {\n                                fieldsMetadata.push(...(it.fields || []));\n                            });\n                        }\n                        fieldsMetadata.push(...interfaceType.fields);\n                        let fields = fieldsMetadata.reduce((fieldsMap, field) => {\n                            const fieldResolverMetadata = (0, getMetadataStorage_1.getMetadataStorage)().fieldResolvers.find(resolver => resolver.getObjectType() === field.target &&\n                                resolver.methodName === field.name);\n                            const type = this.getGraphQLOutputType(field.target, field.name, field.getType(), field.typeOptions);\n                            fieldsMap[field.schemaName] = {\n                                type,\n                                args: this.generateHandlerArgs(field.target, field.name, field.params),\n                                resolve: fieldResolverMetadata\n                                    ? (0, create_1.createAdvancedFieldResolver)(fieldResolverMetadata)\n                                    : (0, create_1.createBasicFieldResolver)(field),\n                                description: field.description,\n                                deprecationReason: field.deprecationReason,\n                                astNode: (0, definition_node_1.getFieldDefinitionNode)(field.name, type, field.directives),\n                                extensions: {\n                                    complexity: field.complexity,\n                                    ...field.extensions,\n                                },\n                            };\n                            return fieldsMap;\n                        }, {});\n                        if (hasExtended) {\n                            const superClass = getSuperClassType();\n                            if (superClass) {\n                                const superClassFields = (0, utils_1.getFieldMetadataFromObjectType)(superClass);\n                                fields = { ...superClassFields, ...fields };\n                            }\n                        }\n                        return fields;\n                    },\n                    resolveType: interfaceType.resolveType\n                        ? this.getResolveTypeFunction(interfaceType.resolveType, implementingObjectTypesInfo)\n                        : instance => {\n                            const typeTarget = implementingObjectTypesTargets.find(typeCls => instance instanceof typeCls);\n                            if (!typeTarget) {\n                                throw new errors_1.InterfaceResolveTypeError(interfaceType);\n                            }\n                            const objectTypeInfo = implementingObjectTypesInfo.find(type => type.target === typeTarget);\n                            return objectTypeInfo?.type.name;\n                        },\n                }),\n            };\n        });\n        this.inputTypesInfo = (0, getMetadataStorage_1.getMetadataStorage)().inputTypes.map(inputType => {\n            const objectSuperClass = Object.getPrototypeOf(inputType.target);\n            const getSuperClassType = () => {\n                const superClassTypeInfo = this.inputTypesInfo.find(type => type.target === objectSuperClass);\n                return superClassTypeInfo ? superClassTypeInfo.type : undefined;\n            };\n            const inputInstance = new inputType.target();\n            return {\n                target: inputType.target,\n                type: new graphql_1.GraphQLInputObjectType({\n                    name: inputType.name,\n                    description: inputType.description,\n                    extensions: inputType.extensions,\n                    fields: () => {\n                        let fields = inputType.fields.reduce((fieldsMap, field) => {\n                            const defaultValue = this.getDefaultValue(inputInstance, field.typeOptions, field.name, inputType.name);\n                            const type = this.getGraphQLInputType(field.target, field.name, field.getType(), {\n                                ...field.typeOptions,\n                                defaultValue,\n                            });\n                            fieldsMap[field.name] = {\n                                description: field.description,\n                                type,\n                                defaultValue,\n                                astNode: (0, definition_node_1.getInputValueDefinitionNode)(field.name, type, field.directives),\n                                extensions: field.extensions,\n                                deprecationReason: field.deprecationReason,\n                            };\n                            return fieldsMap;\n                        }, {});\n                        if (objectSuperClass.prototype !== undefined) {\n                            const superClass = getSuperClassType();\n                            if (superClass) {\n                                const superClassFields = (0, utils_1.getFieldMetadataFromInputType)(superClass);\n                                fields = { ...superClassFields, ...fields };\n                            }\n                        }\n                        return fields;\n                    },\n                    astNode: (0, definition_node_1.getInputObjectTypeDefinitionNode)(inputType.name, inputType.directives),\n                }),\n            };\n        });\n    }\n    static buildRootQueryType(resolvers) {\n        const queriesHandlers = this.filterHandlersByResolvers((0, getMetadataStorage_1.getMetadataStorage)().queries, resolvers);\n        return new graphql_1.GraphQLObjectType({\n            name: \"Query\",\n            fields: this.generateHandlerFields(queriesHandlers),\n        });\n    }\n    static buildRootMutationType(resolvers) {\n        const mutationsHandlers = this.filterHandlersByResolvers((0, getMetadataStorage_1.getMetadataStorage)().mutations, resolvers);\n        if (mutationsHandlers.length === 0) {\n            return undefined;\n        }\n        return new graphql_1.GraphQLObjectType({\n            name: \"Mutation\",\n            fields: this.generateHandlerFields(mutationsHandlers),\n        });\n    }\n    static buildRootSubscriptionType(resolvers) {\n        const subscriptionsHandlers = this.filterHandlersByResolvers((0, getMetadataStorage_1.getMetadataStorage)().subscriptions, resolvers);\n        if (subscriptionsHandlers.length === 0) {\n            return undefined;\n        }\n        return new graphql_1.GraphQLObjectType({\n            name: \"Subscription\",\n            fields: this.generateSubscriptionsFields(subscriptionsHandlers),\n        });\n    }\n    static buildOtherTypes(orphanedTypes) {\n        const autoRegisteredObjectTypesInfo = this.objectTypesInfo.filter(typeInfo => typeInfo.metadata.interfaceClasses?.some(interfaceClass => {\n            const implementedInterfaceInfo = this.interfaceTypesInfo.find(it => it.target === interfaceClass);\n            if (!implementedInterfaceInfo) {\n                return false;\n            }\n            if (implementedInterfaceInfo.metadata.autoRegisteringDisabled) {\n                return false;\n            }\n            if (!this.usedInterfaceTypes.has(interfaceClass)) {\n                return false;\n            }\n            return true;\n        }));\n        return [\n            ...this.filterTypesInfoByOrphanedTypesAndExtractType(this.objectTypesInfo, orphanedTypes),\n            ...this.filterTypesInfoByOrphanedTypesAndExtractType(this.interfaceTypesInfo, orphanedTypes),\n            ...this.filterTypesInfoByOrphanedTypesAndExtractType(this.inputTypesInfo, orphanedTypes),\n            ...autoRegisteredObjectTypesInfo.map(typeInfo => typeInfo.type),\n        ];\n    }\n    static generateHandlerFields(handlers) {\n        return handlers.reduce((fields, handler) => {\n            const type = this.getGraphQLOutputType(handler.target, handler.methodName, handler.getReturnType(), handler.returnTypeOptions);\n            fields[handler.schemaName] = {\n                type,\n                args: this.generateHandlerArgs(handler.target, handler.methodName, handler.params),\n                resolve: (0, create_1.createHandlerResolver)(handler),\n                description: handler.description,\n                deprecationReason: handler.deprecationReason,\n                astNode: (0, definition_node_1.getFieldDefinitionNode)(handler.schemaName, type, handler.directives),\n                extensions: {\n                    complexity: handler.complexity,\n                    ...handler.extensions,\n                },\n            };\n            return fields;\n        }, {});\n    }\n    static generateSubscriptionsFields(subscriptionsHandlers) {\n        if (!subscriptionsHandlers.length) {\n            return {};\n        }\n        const { pubSub, container } = build_context_1.BuildContext;\n        if (!pubSub) {\n            throw new errors_1.MissingPubSubError();\n        }\n        const basicFields = this.generateHandlerFields(subscriptionsHandlers);\n        return subscriptionsHandlers.reduce((fields, handler) => {\n            let subscribeFn;\n            if (handler.subscribe) {\n                subscribeFn = (source, args, context, info) => {\n                    const subscribeResolverData = { source, args, context, info };\n                    return handler.subscribe(subscribeResolverData);\n                };\n            }\n            else {\n                subscribeFn = (source, args, context, info) => {\n                    const subscribeResolverData = { source, args, context, info };\n                    let topics;\n                    if (typeof handler.topics === \"function\") {\n                        const getTopics = handler.topics;\n                        topics = getTopics(subscribeResolverData);\n                    }\n                    else {\n                        topics = handler.topics;\n                    }\n                    const topicId = handler.topicId?.(subscribeResolverData);\n                    let pubSubIterable;\n                    if (!Array.isArray(topics)) {\n                        pubSubIterable = pubSub.subscribe(topics, topicId);\n                    }\n                    else {\n                        if (topics.length === 0) {\n                            throw new errors_1.MissingSubscriptionTopicsError(handler.target, handler.methodName);\n                        }\n                        pubSubIterable = subscription_1.Repeater.merge([\n                            ...topics.map(topic => pubSub.subscribe(topic, topicId)),\n                        ]);\n                    }\n                    if (!handler.filter) {\n                        return pubSubIterable;\n                    }\n                    return (0, subscription_1.pipe)(pubSubIterable, (0, subscription_1.filter)(payload => {\n                        const handlerData = { payload, args, context, info };\n                        return handler.filter(handlerData);\n                    }));\n                };\n            }\n            fields[handler.schemaName].subscribe = (0, create_1.wrapResolverWithAuthChecker)(subscribeFn, container, handler.roles);\n            return fields;\n        }, basicFields);\n    }\n    static generateHandlerArgs(target, propertyName, params) {\n        return params.reduce((args, param) => {\n            if (param.kind === \"arg\") {\n                const type = this.getGraphQLInputType(target, propertyName, param.getType(), param.typeOptions, param.index, param.name);\n                const argDirectives = (0, getMetadataStorage_1.getMetadataStorage)()\n                    .argumentDirectives.filter(it => it.target === target &&\n                    it.fieldName === propertyName &&\n                    it.parameterIndex === param.index)\n                    .map(it => it.directive);\n                args[param.name] = {\n                    description: param.description,\n                    type,\n                    defaultValue: param.typeOptions.defaultValue,\n                    deprecationReason: param.deprecationReason,\n                    astNode: (0, definition_node_1.getInputValueDefinitionNode)(param.name, type, argDirectives),\n                };\n            }\n            else if (param.kind === \"args\") {\n                const argumentType = (0, getMetadataStorage_1.getMetadataStorage)().argumentTypes.find(it => it.target === param.getType());\n                if (!argumentType) {\n                    throw new Error(`The value used as a type of '@Args' for '${propertyName}' of '${target.name}' ` +\n                        `is not a class decorated with '@ArgsType' decorator!`);\n                }\n                const inheritanceChainClasses = [argumentType.target];\n                for (let superClass = argumentType.target; superClass.prototype !== undefined; superClass = Object.getPrototypeOf(superClass)) {\n                    inheritanceChainClasses.push(superClass);\n                }\n                for (const argsTypeClass of inheritanceChainClasses.reverse()) {\n                    const inheritedArgumentType = (0, getMetadataStorage_1.getMetadataStorage)().argumentTypes.find(it => it.target === argsTypeClass);\n                    if (inheritedArgumentType) {\n                        this.mapArgFields(inheritedArgumentType, args);\n                    }\n                }\n            }\n            return args;\n        }, {});\n    }\n    static mapArgFields(argumentType, args = {}) {\n        const argumentInstance = new argumentType.target();\n        argumentType.fields.forEach(field => {\n            const defaultValue = this.getDefaultValue(argumentInstance, field.typeOptions, field.name, argumentType.name);\n            const type = this.getGraphQLInputType(field.target, field.name, field.getType(), {\n                ...field.typeOptions,\n                defaultValue,\n            });\n            args[field.schemaName] = {\n                description: field.description,\n                type,\n                defaultValue,\n                astNode: (0, definition_node_1.getInputValueDefinitionNode)(field.name, type, field.directives),\n                extensions: field.extensions,\n                deprecationReason: field.deprecationReason,\n            };\n        });\n    }\n    static getGraphQLOutputType(target, propertyName, type, typeOptions = {}) {\n        let gqlType;\n        gqlType = (0, types_1.convertTypeIfScalar)(type);\n        if (!gqlType) {\n            const objectType = this.objectTypesInfo.find(it => it.target === type);\n            if (objectType) {\n                gqlType = objectType.type;\n            }\n        }\n        if (!gqlType) {\n            const interfaceType = this.interfaceTypesInfo.find(it => it.target === type);\n            if (interfaceType) {\n                this.usedInterfaceTypes.add(interfaceType.target);\n                gqlType = interfaceType.type;\n            }\n        }\n        if (!gqlType) {\n            const enumType = this.enumTypesInfo.find(it => it.enumObj === type);\n            if (enumType) {\n                gqlType = enumType.type;\n            }\n        }\n        if (!gqlType) {\n            const unionType = this.unionTypesInfo.find(it => it.unionSymbol === type);\n            if (unionType) {\n                gqlType = unionType.type;\n            }\n        }\n        if (!gqlType) {\n            throw new errors_1.CannotDetermineGraphQLTypeError(\"output\", target.name, propertyName);\n        }\n        const { nullableByDefault } = build_context_1.BuildContext;\n        return (0, types_1.wrapWithTypeOptions)(target, propertyName, gqlType, typeOptions, nullableByDefault);\n    }\n    static getGraphQLInputType(target, propertyName, type, typeOptions = {}, parameterIndex, argName) {\n        let gqlType;\n        gqlType = (0, types_1.convertTypeIfScalar)(type);\n        if (!gqlType) {\n            const inputType = this.inputTypesInfo.find(it => it.target === type);\n            if (inputType) {\n                gqlType = inputType.type;\n            }\n        }\n        if (!gqlType) {\n            const enumType = this.enumTypesInfo.find(it => it.enumObj === type);\n            if (enumType) {\n                gqlType = enumType.type;\n            }\n        }\n        if (!gqlType) {\n            throw new errors_1.CannotDetermineGraphQLTypeError(\"input\", target.name, propertyName, parameterIndex, argName);\n        }\n        const { nullableByDefault } = build_context_1.BuildContext;\n        return (0, types_1.wrapWithTypeOptions)(target, propertyName, gqlType, typeOptions, nullableByDefault);\n    }\n    static getResolveTypeFunction(resolveType, possibleObjectTypesInfo) {\n        return async (...args) => {\n            const resolvedType = await resolveType(...args);\n            if (!resolvedType || typeof resolvedType === \"string\") {\n                return resolvedType ?? undefined;\n            }\n            return possibleObjectTypesInfo.find(objectType => objectType.target === resolvedType)?.type\n                .name;\n        };\n    }\n    static filterHandlersByResolvers(handlers, resolvers) {\n        return handlers.filter(query => resolvers.includes(query.target));\n    }\n    static filterTypesInfoByOrphanedTypesAndExtractType(typesInfo, orphanedTypes) {\n        return typesInfo.filter(it => orphanedTypes.includes(it.target)).map(it => it.type);\n    }\n}\nexports.SchemaGenerator = SchemaGenerator;\nSchemaGenerator.objectTypesInfo = [];\nSchemaGenerator.inputTypesInfo = [];\nSchemaGenerator.interfaceTypesInfo = [];\nSchemaGenerator.enumTypesInfo = [];\nSchemaGenerator.unionTypesInfo = [];\nSchemaGenerator.usedInterfaceTypes = new Set();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}