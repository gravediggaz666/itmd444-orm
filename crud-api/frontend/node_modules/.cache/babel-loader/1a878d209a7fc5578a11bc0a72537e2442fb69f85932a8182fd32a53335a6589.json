{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2017, Dirk-Jan Rutten\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateJSDate = exports.validateUnixTimestamp = exports.validateDateTime = exports.validateDate = exports.validateTime = void 0;\n// Check whether a certain year is a leap year.\n//\n// Every year that is exactly divisible by four\n// is a leap year, except for years that are exactly\n// divisible by 100, but these centurial years are\n// leap years if they are exactly divisible by 400.\n// For example, the years 1700, 1800, and 1900 are not leap years,\n// but the years 1600 and 2000 are.\n//\nconst leapYear = year => {\n  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n};\n// Function that checks whether a time-string is RFC 3339 compliant.\n//\n// It checks whether the time-string is structured in one of the\n// following formats:\n//\n// - hh:mm:ssZ\n// - hh:mm:ss±hh:mm\n// - hh:mm:ss.*sZ\n// - hh:mm:ss.*s±hh:mm\n//\n// Where *s is a fraction of seconds with at least 1 digit.\n//\n// Note, this validator assumes that all minutes have\n// 59 seconds. This assumption does not follow RFC 3339\n// which includes leap seconds (in which case it is possible that\n// there are 60 seconds in a minute).\n//\n// Leap seconds are ignored because it adds complexity in\n// the following areas:\n// - The native Javascript Date ignores them; i.e. Date.parse('1972-12-31T23:59:60Z')\n//   equals NaN.\n// - Leap seconds cannot be known in advance.\n//\nconst validateTime = time => {\n  time = time === null || time === void 0 ? void 0 : time.toUpperCase();\n  const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\\.\\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\n  return TIME_REGEX.test(time);\n};\nexports.validateTime = validateTime;\n// Function that checks whether a date-string is RFC 3339 compliant.\n//\n// It checks whether the date-string is a valid date in the YYYY-MM-DD.\n//\n// Note, the number of days in each date are determined according to the\n// following lookup table:\n//\n// Month Number  Month/Year           Maximum value of date-mday\n// ------------  ----------           --------------------------\n// 01            January              31\n// 02            February, normal     28\n// 02            February, leap year  29\n// 03            March                31\n// 04            April                30\n// 05            May                  31\n// 06            June                 30\n// 07            July                 31\n// 08            August               31\n// 09            September            30\n// 10            October              31\n// 11            November             30\n// 12            December             31\n//\nconst validateDate = datestring => {\n  const RFC_3339_REGEX = /^(\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;\n  if (!RFC_3339_REGEX.test(datestring)) {\n    return false;\n  }\n  // Verify the correct number of days for\n  // the month contained in the date-string.\n  const year = Number(datestring.substr(0, 4));\n  const month = Number(datestring.substr(5, 2));\n  const day = Number(datestring.substr(8, 2));\n  switch (month) {\n    case 2:\n      // February\n      if (leapYear(year) && day > 29) {\n        return false;\n      } else if (!leapYear(year) && day > 28) {\n        return false;\n      }\n      return true;\n    case 4: // April\n    case 6: // June\n    case 9: // September\n    case 11:\n      // November\n      if (day > 30) {\n        return false;\n      }\n      break;\n  }\n  return true;\n};\nexports.validateDate = validateDate;\n// Function that checks whether a date-time-string is RFC 3339 compliant.\n//\n// It checks whether the time-string is structured in one of the\n//\n// - YYYY-MM-DDThh:mm:ssZ\n// - YYYY-MM-DDThh:mm:ss±hh:mm\n// - YYYY-MM-DDThh:mm:ss.*sZ\n// - YYYY-MM-DDThh:mm:ss.*s±hh:mm\n//\n// Where *s is a fraction of seconds with at least 1 digit.\n//\nconst validateDateTime = dateTimeString => {\n  dateTimeString = dateTimeString === null || dateTimeString === void 0 ? void 0 : dateTimeString.toUpperCase();\n  const RFC_3339_REGEX = /^(\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\\.\\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\n  // Validate the structure of the date-string\n  if (!RFC_3339_REGEX.test(dateTimeString)) {\n    return false;\n  }\n  // Check if it is a correct date using the javascript Date parse() method.\n  const time = Date.parse(dateTimeString);\n  if (time !== time) {\n    // eslint-disable-line\n    return false;\n  }\n  // Split the date-time-string up into the string-date and time-string part.\n  // and check whether these parts are RFC 3339 compliant.\n  const index = dateTimeString.indexOf('T');\n  const dateString = dateTimeString.substr(0, index);\n  const timeString = dateTimeString.substr(index + 1);\n  return (0, exports.validateDate)(dateString) && (0, exports.validateTime)(timeString);\n};\nexports.validateDateTime = validateDateTime;\n// Function that checks whether a given number is a valid\n// Unix timestamp.\n//\n// Unix timestamps are signed 32-bit integers. They are interpreted\n// as the number of seconds since 00:00:00 UTC on 1 January 1970.\n//\nconst validateUnixTimestamp = timestamp => {\n  const MAX_INT = 2147483647;\n  const MIN_INT = -2147483648;\n  return timestamp === timestamp && timestamp <= MAX_INT && timestamp >= MIN_INT; // eslint-disable-line\n};\nexports.validateUnixTimestamp = validateUnixTimestamp;\n// Function that checks whether a javascript Date instance\n// is valid.\n//\nconst validateJSDate = date => {\n  const time = date.getTime();\n  return time === time; // eslint-disable-line\n};\nexports.validateJSDate = validateJSDate;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateJSDate","validateUnixTimestamp","validateDateTime","validateDate","validateTime","leapYear","year","time","toUpperCase","TIME_REGEX","test","datestring","RFC_3339_REGEX","Number","substr","month","day","dateTimeString","Date","parse","index","indexOf","dateString","timeString","timestamp","MAX_INT","MIN_INT","date","getTime"],"sources":["/Users/snawz1/node_modules/graphql-scalars/cjs/scalars/iso-date/validator.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2017, Dirk-Jan Rutten\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateJSDate = exports.validateUnixTimestamp = exports.validateDateTime = exports.validateDate = exports.validateTime = void 0;\n// Check whether a certain year is a leap year.\n//\n// Every year that is exactly divisible by four\n// is a leap year, except for years that are exactly\n// divisible by 100, but these centurial years are\n// leap years if they are exactly divisible by 400.\n// For example, the years 1700, 1800, and 1900 are not leap years,\n// but the years 1600 and 2000 are.\n//\nconst leapYear = (year) => {\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n};\n// Function that checks whether a time-string is RFC 3339 compliant.\n//\n// It checks whether the time-string is structured in one of the\n// following formats:\n//\n// - hh:mm:ssZ\n// - hh:mm:ss±hh:mm\n// - hh:mm:ss.*sZ\n// - hh:mm:ss.*s±hh:mm\n//\n// Where *s is a fraction of seconds with at least 1 digit.\n//\n// Note, this validator assumes that all minutes have\n// 59 seconds. This assumption does not follow RFC 3339\n// which includes leap seconds (in which case it is possible that\n// there are 60 seconds in a minute).\n//\n// Leap seconds are ignored because it adds complexity in\n// the following areas:\n// - The native Javascript Date ignores them; i.e. Date.parse('1972-12-31T23:59:60Z')\n//   equals NaN.\n// - Leap seconds cannot be known in advance.\n//\nconst validateTime = (time) => {\n    time = time === null || time === void 0 ? void 0 : time.toUpperCase();\n    const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\\.\\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\n    return TIME_REGEX.test(time);\n};\nexports.validateTime = validateTime;\n// Function that checks whether a date-string is RFC 3339 compliant.\n//\n// It checks whether the date-string is a valid date in the YYYY-MM-DD.\n//\n// Note, the number of days in each date are determined according to the\n// following lookup table:\n//\n// Month Number  Month/Year           Maximum value of date-mday\n// ------------  ----------           --------------------------\n// 01            January              31\n// 02            February, normal     28\n// 02            February, leap year  29\n// 03            March                31\n// 04            April                30\n// 05            May                  31\n// 06            June                 30\n// 07            July                 31\n// 08            August               31\n// 09            September            30\n// 10            October              31\n// 11            November             30\n// 12            December             31\n//\nconst validateDate = (datestring) => {\n    const RFC_3339_REGEX = /^(\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;\n    if (!RFC_3339_REGEX.test(datestring)) {\n        return false;\n    }\n    // Verify the correct number of days for\n    // the month contained in the date-string.\n    const year = Number(datestring.substr(0, 4));\n    const month = Number(datestring.substr(5, 2));\n    const day = Number(datestring.substr(8, 2));\n    switch (month) {\n        case 2: // February\n            if (leapYear(year) && day > 29) {\n                return false;\n            }\n            else if (!leapYear(year) && day > 28) {\n                return false;\n            }\n            return true;\n        case 4: // April\n        case 6: // June\n        case 9: // September\n        case 11: // November\n            if (day > 30) {\n                return false;\n            }\n            break;\n    }\n    return true;\n};\nexports.validateDate = validateDate;\n// Function that checks whether a date-time-string is RFC 3339 compliant.\n//\n// It checks whether the time-string is structured in one of the\n//\n// - YYYY-MM-DDThh:mm:ssZ\n// - YYYY-MM-DDThh:mm:ss±hh:mm\n// - YYYY-MM-DDThh:mm:ss.*sZ\n// - YYYY-MM-DDThh:mm:ss.*s±hh:mm\n//\n// Where *s is a fraction of seconds with at least 1 digit.\n//\nconst validateDateTime = (dateTimeString) => {\n    dateTimeString = dateTimeString === null || dateTimeString === void 0 ? void 0 : dateTimeString.toUpperCase();\n    const RFC_3339_REGEX = /^(\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\\.\\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\n    // Validate the structure of the date-string\n    if (!RFC_3339_REGEX.test(dateTimeString)) {\n        return false;\n    }\n    // Check if it is a correct date using the javascript Date parse() method.\n    const time = Date.parse(dateTimeString);\n    if (time !== time) {\n        // eslint-disable-line\n        return false;\n    }\n    // Split the date-time-string up into the string-date and time-string part.\n    // and check whether these parts are RFC 3339 compliant.\n    const index = dateTimeString.indexOf('T');\n    const dateString = dateTimeString.substr(0, index);\n    const timeString = dateTimeString.substr(index + 1);\n    return (0, exports.validateDate)(dateString) && (0, exports.validateTime)(timeString);\n};\nexports.validateDateTime = validateDateTime;\n// Function that checks whether a given number is a valid\n// Unix timestamp.\n//\n// Unix timestamps are signed 32-bit integers. They are interpreted\n// as the number of seconds since 00:00:00 UTC on 1 January 1970.\n//\nconst validateUnixTimestamp = (timestamp) => {\n    const MAX_INT = 2147483647;\n    const MIN_INT = -2147483648;\n    return (timestamp === timestamp && timestamp <= MAX_INT && timestamp >= MIN_INT); // eslint-disable-line\n};\nexports.validateUnixTimestamp = validateUnixTimestamp;\n// Function that checks whether a javascript Date instance\n// is valid.\n//\nconst validateJSDate = (date) => {\n    const time = date.getTime();\n    return time === time; // eslint-disable-line\n};\nexports.validateJSDate = validateJSDate;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}