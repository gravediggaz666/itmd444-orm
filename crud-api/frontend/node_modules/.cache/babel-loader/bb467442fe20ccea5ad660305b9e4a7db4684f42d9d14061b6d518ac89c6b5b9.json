{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertArgToInstance = exports.convertArgsToInstance = void 0;\nconst types_1 = require(\"../helpers/types\");\nconst getMetadataStorage_1 = require(\"../metadata/getMetadataStorage\");\nconst generatedTrees = new Map();\nfunction getInputType(target) {\n  return (0, getMetadataStorage_1.getMetadataStorage)().inputTypes.find(t => t.target === target);\n}\nfunction getArgsType(target) {\n  return (0, getMetadataStorage_1.getMetadataStorage)().argumentTypes.find(t => t.target === target);\n}\nfunction generateInstanceTransformationTree(target) {\n  if (generatedTrees.has(target)) {\n    return generatedTrees.get(target);\n  }\n  const inputType = getInputType(target);\n  if (!inputType) {\n    generatedTrees.set(target, null);\n    return null;\n  }\n  function generateTransformationTree(metadata) {\n    let inputFields = metadata.fields;\n    let superClass = Object.getPrototypeOf(metadata.target);\n    while (superClass.prototype !== undefined) {\n      const superInputType = getInputType(superClass);\n      if (superInputType) {\n        const existingFieldNames = new Set(inputFields.map(field => field.name));\n        const superFields = superInputType.fields.filter(field => !existingFieldNames.has(field.name));\n        inputFields = [...inputFields, ...superFields];\n      }\n      superClass = Object.getPrototypeOf(superClass);\n    }\n    const transformationTree = {\n      target: metadata.target,\n      getFields: () => inputFields.map(field => {\n        const fieldTarget = field.getType();\n        const fieldInputType = getInputType(fieldTarget);\n        return {\n          name: field.name,\n          target: fieldTarget,\n          fields: fieldTarget === metadata.target ? transformationTree : fieldInputType && generateTransformationTree(fieldInputType)\n        };\n      })\n    };\n    return transformationTree;\n  }\n  const generatedTransformationTree = generateTransformationTree(inputType);\n  generatedTrees.set(target, generatedTransformationTree);\n  return generatedTransformationTree;\n}\nfunction convertToInput(tree, data) {\n  if (data == null) {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    return data.map(it => convertToInput(tree, it));\n  }\n  const inputFields = tree.getFields().reduce((fields, field) => {\n    const siblings = field.fields;\n    const value = data[field.name];\n    if (value !== undefined) {\n      if (value === null || !siblings) {\n        fields[field.name] = (0, types_1.convertToType)(field.target, value);\n      } else if (Array.isArray(value)) {\n        fields[field.name] = value.map(itemValue => convertToInput(siblings, itemValue));\n      } else {\n        fields[field.name] = convertToInput(siblings, value);\n      }\n    }\n    return fields;\n  }, {});\n  return (0, types_1.convertToType)(tree.target, inputFields);\n}\nfunction convertValueToInstance(target, value) {\n  const transformationTree = generateInstanceTransformationTree(target);\n  return transformationTree ? convertToInput(transformationTree, value) : (0, types_1.convertToType)(target, value);\n}\nfunction convertValuesToInstances(target, value) {\n  if (value == null) {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(itemValue => convertValuesToInstances(target, itemValue));\n  }\n  return convertValueToInstance(target, value);\n}\nfunction convertArgsToInstance(argsMetadata, args) {\n  const ArgsClass = argsMetadata.getType();\n  const argsType = getArgsType(ArgsClass);\n  let argsFields = argsType.fields;\n  let superClass = Object.getPrototypeOf(argsType.target);\n  while (superClass.prototype !== undefined) {\n    const superArgumentType = getArgsType(superClass);\n    if (superArgumentType) {\n      argsFields = [...argsFields, ...superArgumentType.fields];\n    }\n    superClass = Object.getPrototypeOf(superClass);\n  }\n  const transformedFields = argsFields.reduce((fields, field) => {\n    const fieldValue = args[field.name];\n    if (fieldValue !== undefined) {\n      const fieldTarget = field.getType();\n      fields[field.name] = convertValuesToInstances(fieldTarget, fieldValue);\n    }\n    return fields;\n  }, {});\n  return (0, types_1.convertToType)(ArgsClass, transformedFields);\n}\nexports.convertArgsToInstance = convertArgsToInstance;\nfunction convertArgToInstance(argMetadata, args) {\n  const argValue = args[argMetadata.name];\n  const argTarget = argMetadata.getType();\n  return convertValuesToInstances(argTarget, argValue);\n}\nexports.convertArgToInstance = convertArgToInstance;","map":{"version":3,"names":["Object","defineProperty","exports","value","convertArgToInstance","convertArgsToInstance","types_1","require","getMetadataStorage_1","generatedTrees","Map","getInputType","target","getMetadataStorage","inputTypes","find","t","getArgsType","argumentTypes","generateInstanceTransformationTree","has","get","inputType","set","generateTransformationTree","metadata","inputFields","fields","superClass","getPrototypeOf","prototype","undefined","superInputType","existingFieldNames","Set","map","field","name","superFields","filter","transformationTree","getFields","fieldTarget","getType","fieldInputType","generatedTransformationTree","convertToInput","tree","data","Array","isArray","it","reduce","siblings","convertToType","itemValue","convertValueToInstance","convertValuesToInstances","argsMetadata","args","ArgsClass","argsType","argsFields","superArgumentType","transformedFields","fieldValue","argMetadata","argValue","argTarget"],"sources":["/Users/snawz1/node_modules/type-graphql/build/cjs/resolvers/convert-args.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertArgToInstance = exports.convertArgsToInstance = void 0;\nconst types_1 = require(\"../helpers/types\");\nconst getMetadataStorage_1 = require(\"../metadata/getMetadataStorage\");\nconst generatedTrees = new Map();\nfunction getInputType(target) {\n    return (0, getMetadataStorage_1.getMetadataStorage)().inputTypes.find(t => t.target === target);\n}\nfunction getArgsType(target) {\n    return (0, getMetadataStorage_1.getMetadataStorage)().argumentTypes.find(t => t.target === target);\n}\nfunction generateInstanceTransformationTree(target) {\n    if (generatedTrees.has(target)) {\n        return generatedTrees.get(target);\n    }\n    const inputType = getInputType(target);\n    if (!inputType) {\n        generatedTrees.set(target, null);\n        return null;\n    }\n    function generateTransformationTree(metadata) {\n        let inputFields = metadata.fields;\n        let superClass = Object.getPrototypeOf(metadata.target);\n        while (superClass.prototype !== undefined) {\n            const superInputType = getInputType(superClass);\n            if (superInputType) {\n                const existingFieldNames = new Set(inputFields.map(field => field.name));\n                const superFields = superInputType.fields.filter(field => !existingFieldNames.has(field.name));\n                inputFields = [...inputFields, ...superFields];\n            }\n            superClass = Object.getPrototypeOf(superClass);\n        }\n        const transformationTree = {\n            target: metadata.target,\n            getFields: () => inputFields.map(field => {\n                const fieldTarget = field.getType();\n                const fieldInputType = getInputType(fieldTarget);\n                return {\n                    name: field.name,\n                    target: fieldTarget,\n                    fields: fieldTarget === metadata.target\n                        ? transformationTree\n                        : fieldInputType && generateTransformationTree(fieldInputType),\n                };\n            }),\n        };\n        return transformationTree;\n    }\n    const generatedTransformationTree = generateTransformationTree(inputType);\n    generatedTrees.set(target, generatedTransformationTree);\n    return generatedTransformationTree;\n}\nfunction convertToInput(tree, data) {\n    if (data == null) {\n        return data;\n    }\n    if (Array.isArray(data)) {\n        return data.map(it => convertToInput(tree, it));\n    }\n    const inputFields = tree.getFields().reduce((fields, field) => {\n        const siblings = field.fields;\n        const value = data[field.name];\n        if (value !== undefined) {\n            if (value === null || !siblings) {\n                fields[field.name] = (0, types_1.convertToType)(field.target, value);\n            }\n            else if (Array.isArray(value)) {\n                fields[field.name] = value.map(itemValue => convertToInput(siblings, itemValue));\n            }\n            else {\n                fields[field.name] = convertToInput(siblings, value);\n            }\n        }\n        return fields;\n    }, {});\n    return (0, types_1.convertToType)(tree.target, inputFields);\n}\nfunction convertValueToInstance(target, value) {\n    const transformationTree = generateInstanceTransformationTree(target);\n    return transformationTree\n        ? convertToInput(transformationTree, value)\n        : (0, types_1.convertToType)(target, value);\n}\nfunction convertValuesToInstances(target, value) {\n    if (value == null) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(itemValue => convertValuesToInstances(target, itemValue));\n    }\n    return convertValueToInstance(target, value);\n}\nfunction convertArgsToInstance(argsMetadata, args) {\n    const ArgsClass = argsMetadata.getType();\n    const argsType = getArgsType(ArgsClass);\n    let argsFields = argsType.fields;\n    let superClass = Object.getPrototypeOf(argsType.target);\n    while (superClass.prototype !== undefined) {\n        const superArgumentType = getArgsType(superClass);\n        if (superArgumentType) {\n            argsFields = [...argsFields, ...superArgumentType.fields];\n        }\n        superClass = Object.getPrototypeOf(superClass);\n    }\n    const transformedFields = argsFields.reduce((fields, field) => {\n        const fieldValue = args[field.name];\n        if (fieldValue !== undefined) {\n            const fieldTarget = field.getType();\n            fields[field.name] = convertValuesToInstances(fieldTarget, fieldValue);\n        }\n        return fields;\n    }, {});\n    return (0, types_1.convertToType)(ArgsClass, transformedFields);\n}\nexports.convertArgsToInstance = convertArgsToInstance;\nfunction convertArgToInstance(argMetadata, args) {\n    const argValue = args[argMetadata.name];\n    const argTarget = argMetadata.getType();\n    return convertValuesToInstances(argTarget, argValue);\n}\nexports.convertArgToInstance = convertArgToInstance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}