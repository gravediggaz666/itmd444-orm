{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLLocalDate = void 0;\nconst graphql_1 = require(\"graphql\");\nconst error_js_1 = require(\"../error.js\");\nconst LOCAL_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}$/;\nfunction validateLocalDate(value, ast) {\n  if (typeof value !== 'string') {\n    throw (0, error_js_1.createGraphQLError)(`Value is not string: ${value}`, ast ? {\n      nodes: ast\n    } : undefined);\n  }\n  // check that it's in the `yyyy-MM-dd` format\n  const isValidFormat = LOCAL_DATE_FORMAT.test(value);\n  if (!isValidFormat) {\n    throw (0, error_js_1.createGraphQLError)(`Value is not a valid LocalDate: ${value}`, ast ? {\n      nodes: ast\n    } : undefined);\n  }\n  // check that it appears to be a valid date, e.g., not something like `2020-13-46`\n  const valueAsDate = new Date(value);\n  const isValidDate = !isNaN(valueAsDate.getTime());\n  if (!isValidDate) {\n    throw (0, error_js_1.createGraphQLError)(`Value is not a valid LocalDate: ${value}`, ast ? {\n      nodes: ast\n    } : undefined);\n  }\n  // some additional logic to catch invalid dates like `2020-02-30`\n  // that we catch by serializing the Date object into an ISO string and checking that our serialized date matches\n  // the original value\n  const isCalendarDate = valueAsDate.toISOString() === `${value}T00:00:00.000Z`;\n  if (!isCalendarDate) {\n    throw (0, error_js_1.createGraphQLError)(`Value is not a valid LocalDate: ${value}`, ast ? {\n      nodes: ast\n    } : undefined);\n  }\n  return value;\n}\nexports.GraphQLLocalDate = new graphql_1.GraphQLScalarType({\n  name: 'LocalDate',\n  description: 'A local date string (i.e., with no associated timezone) in `YYYY-MM-DD` format, e.g. `2020-01-01`.',\n  serialize(value) {\n    // value sent to client as string\n    return validateLocalDate(value);\n  },\n  parseValue(value) {\n    // value from client as json\n    return validateLocalDate(value);\n  },\n  parseLiteral(ast) {\n    // value from client in ast\n    if (ast.kind !== graphql_1.Kind.STRING) {\n      throw (0, error_js_1.createGraphQLError)(`Can only validate strings as local dates but got a: ${ast.kind}`, {\n        nodes: ast\n      });\n    }\n    return validateLocalDate(ast.value, ast);\n  },\n  extensions: {\n    codegenScalarType: 'string',\n    jsonSchema: {\n      title: 'LocalDate',\n      type: 'string',\n      pattern: LOCAL_DATE_FORMAT.source\n    }\n  }\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","GraphQLLocalDate","graphql_1","require","error_js_1","LOCAL_DATE_FORMAT","validateLocalDate","ast","createGraphQLError","nodes","undefined","isValidFormat","test","valueAsDate","Date","isValidDate","isNaN","getTime","isCalendarDate","toISOString","GraphQLScalarType","name","description","serialize","parseValue","parseLiteral","kind","Kind","STRING","extensions","codegenScalarType","jsonSchema","title","type","pattern","source"],"sources":["/Users/snawz1/node_modules/graphql-scalars/cjs/scalars/LocalDate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GraphQLLocalDate = void 0;\nconst graphql_1 = require(\"graphql\");\nconst error_js_1 = require(\"../error.js\");\nconst LOCAL_DATE_FORMAT = /^\\d{4}-\\d{2}-\\d{2}$/;\nfunction validateLocalDate(value, ast) {\n    if (typeof value !== 'string') {\n        throw (0, error_js_1.createGraphQLError)(`Value is not string: ${value}`, ast ? { nodes: ast } : undefined);\n    }\n    // check that it's in the `yyyy-MM-dd` format\n    const isValidFormat = LOCAL_DATE_FORMAT.test(value);\n    if (!isValidFormat) {\n        throw (0, error_js_1.createGraphQLError)(`Value is not a valid LocalDate: ${value}`, ast ? { nodes: ast } : undefined);\n    }\n    // check that it appears to be a valid date, e.g., not something like `2020-13-46`\n    const valueAsDate = new Date(value);\n    const isValidDate = !isNaN(valueAsDate.getTime());\n    if (!isValidDate) {\n        throw (0, error_js_1.createGraphQLError)(`Value is not a valid LocalDate: ${value}`, ast ? { nodes: ast } : undefined);\n    }\n    // some additional logic to catch invalid dates like `2020-02-30`\n    // that we catch by serializing the Date object into an ISO string and checking that our serialized date matches\n    // the original value\n    const isCalendarDate = valueAsDate.toISOString() === `${value}T00:00:00.000Z`;\n    if (!isCalendarDate) {\n        throw (0, error_js_1.createGraphQLError)(`Value is not a valid LocalDate: ${value}`, ast ? { nodes: ast } : undefined);\n    }\n    return value;\n}\nexports.GraphQLLocalDate = new graphql_1.GraphQLScalarType({\n    name: 'LocalDate',\n    description: 'A local date string (i.e., with no associated timezone) in `YYYY-MM-DD` format, e.g. `2020-01-01`.',\n    serialize(value) {\n        // value sent to client as string\n        return validateLocalDate(value);\n    },\n    parseValue(value) {\n        // value from client as json\n        return validateLocalDate(value);\n    },\n    parseLiteral(ast) {\n        // value from client in ast\n        if (ast.kind !== graphql_1.Kind.STRING) {\n            throw (0, error_js_1.createGraphQLError)(`Can only validate strings as local dates but got a: ${ast.kind}`, {\n                nodes: ast,\n            });\n        }\n        return validateLocalDate(ast.value, ast);\n    },\n    extensions: {\n        codegenScalarType: 'string',\n        jsonSchema: {\n            title: 'LocalDate',\n            type: 'string',\n            pattern: LOCAL_DATE_FORMAT.source,\n        },\n    },\n});\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,gBAAgB,GAAG,KAAK,CAAC;AACjC,MAAMC,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,UAAU,GAAGD,OAAO,CAAC,aAAa,CAAC;AACzC,MAAME,iBAAiB,GAAG,qBAAqB;AAC/C,SAASC,iBAAiBA,CAACN,KAAK,EAAEO,GAAG,EAAE;EACnC,IAAI,OAAOP,KAAK,KAAK,QAAQ,EAAE;IAC3B,MAAM,CAAC,CAAC,EAAEI,UAAU,CAACI,kBAAkB,EAAG,wBAAuBR,KAAM,EAAC,EAAEO,GAAG,GAAG;MAAEE,KAAK,EAAEF;IAAI,CAAC,GAAGG,SAAS,CAAC;EAC/G;EACA;EACA,MAAMC,aAAa,GAAGN,iBAAiB,CAACO,IAAI,CAACZ,KAAK,CAAC;EACnD,IAAI,CAACW,aAAa,EAAE;IAChB,MAAM,CAAC,CAAC,EAAEP,UAAU,CAACI,kBAAkB,EAAG,mCAAkCR,KAAM,EAAC,EAAEO,GAAG,GAAG;MAAEE,KAAK,EAAEF;IAAI,CAAC,GAAGG,SAAS,CAAC;EAC1H;EACA;EACA,MAAMG,WAAW,GAAG,IAAIC,IAAI,CAACd,KAAK,CAAC;EACnC,MAAMe,WAAW,GAAG,CAACC,KAAK,CAACH,WAAW,CAACI,OAAO,CAAC,CAAC,CAAC;EACjD,IAAI,CAACF,WAAW,EAAE;IACd,MAAM,CAAC,CAAC,EAAEX,UAAU,CAACI,kBAAkB,EAAG,mCAAkCR,KAAM,EAAC,EAAEO,GAAG,GAAG;MAAEE,KAAK,EAAEF;IAAI,CAAC,GAAGG,SAAS,CAAC;EAC1H;EACA;EACA;EACA;EACA,MAAMQ,cAAc,GAAGL,WAAW,CAACM,WAAW,CAAC,CAAC,KAAM,GAAEnB,KAAM,gBAAe;EAC7E,IAAI,CAACkB,cAAc,EAAE;IACjB,MAAM,CAAC,CAAC,EAAEd,UAAU,CAACI,kBAAkB,EAAG,mCAAkCR,KAAM,EAAC,EAAEO,GAAG,GAAG;MAAEE,KAAK,EAAEF;IAAI,CAAC,GAAGG,SAAS,CAAC;EAC1H;EACA,OAAOV,KAAK;AAChB;AACAD,OAAO,CAACE,gBAAgB,GAAG,IAAIC,SAAS,CAACkB,iBAAiB,CAAC;EACvDC,IAAI,EAAE,WAAW;EACjBC,WAAW,EAAE,oGAAoG;EACjHC,SAASA,CAACvB,KAAK,EAAE;IACb;IACA,OAAOM,iBAAiB,CAACN,KAAK,CAAC;EACnC,CAAC;EACDwB,UAAUA,CAACxB,KAAK,EAAE;IACd;IACA,OAAOM,iBAAiB,CAACN,KAAK,CAAC;EACnC,CAAC;EACDyB,YAAYA,CAAClB,GAAG,EAAE;IACd;IACA,IAAIA,GAAG,CAACmB,IAAI,KAAKxB,SAAS,CAACyB,IAAI,CAACC,MAAM,EAAE;MACpC,MAAM,CAAC,CAAC,EAAExB,UAAU,CAACI,kBAAkB,EAAG,uDAAsDD,GAAG,CAACmB,IAAK,EAAC,EAAE;QACxGjB,KAAK,EAAEF;MACX,CAAC,CAAC;IACN;IACA,OAAOD,iBAAiB,CAACC,GAAG,CAACP,KAAK,EAAEO,GAAG,CAAC;EAC5C,CAAC;EACDsB,UAAU,EAAE;IACRC,iBAAiB,EAAE,QAAQ;IAC3BC,UAAU,EAAE;MACRC,KAAK,EAAE,WAAW;MAClBC,IAAI,EAAE,QAAQ;MACdC,OAAO,EAAE7B,iBAAiB,CAAC8B;IAC/B;EACJ;AACJ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}